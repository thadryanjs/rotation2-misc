
```{julia}

using Random
using Distributions
using Plots
```

## Definitions

 - $N$: numbers of observations per sample.
 - $K$: number batches (can be thought of as number of bootstraps).
 - $n_k$: number of observations per batch ($\frac{N}{K}$).
 - $M$: mean of a sample.
 - $M^{b}$: mean of a batch (bootstrap).
 - $\sigma$: Standard deviation of sample.
 - $\sigma_b$: standard deviation of a batch.
 - $R$: root statistic comparing two means (an empirical mean to a bootstrap).
 - $S$: standard error of a sample ("Outer SE").
 - $S_b$: standard error use in the calculation of $R$ ("Inner SE").
 - $\alpha$: significance level of a comparison.
 - $d$: $1-\alpha$ quantile of a vector of $R$s.

```{julia}

```

```{julia}

Random.seed!(8675309)

n_samples = 2
mu = 2
sd = 0.5
N = 10000
K = 100
n_k = Int(N/K)
normal_dist = Normal(mu, sd)
```

$$
X \sim Normal(\mu, \sigma)
$$

...then,

$$
exp(X) \sim LogNormal(\mu,\sigma)
$$


```{julia}

function generate_sample(mu, sd, N)

    exp_vector(vec) = [exp(i) for i in vec]

    exp_vector(rand(Normal(mu, sd), N))

end

samples = [generate_sample(2, 0.5, N) for i in 1:4]

histogram(samples[1])
```

I will now write a separate function to get the information
```{julia}


function get_batch_info(sample, sample_name, K)    

    # arrays to store means and SDs
    theta_boots = []
    sd_boots = []

    # this algorithm indexes arrays at...
    # 1-100
    # 101-200
    # 201-300
    # etc
    i = 1
    for x in 1:K
        # the upper limits, ie, 1-100
        j = i  + (n_k-1)
        batch = sample[i:j]
        ### (debug) println("from ", i, " to ", j)
        # collect the figures
        push!(theta_boots, mean(batch))
        push!(sd_boots, std(batch))
        # increase by the batch size the set the next limit
        i += n_k
    end
    
    Dict(
        "name" => sample_name,
        "mean" => mean(sample),
        "sd" => std(sample),
        "bootstrap_means" => theta_boots,
        "bootstrap_sds" => sd_boots
    )

end

sample1 = get_batch_info(samples[1], "sample1", K)
```

Now we have a dictionary containing the information about a samples we need to compare it to another.

```{julia}
sample1
```

We will get another sample to compare it to.

```{julia}
sample2 = get_batch_info(samples[2], "sample2", K)
```

## Under the null

```{julia}

function calc_root_stat1(m1, m1b, sd1, m2, m2b, sd2, N)
    # K^1
    se = sqrt( ((sd1^2)/N) + ((sd2^2)/N) )
    abs( (m1b - m2b) - (m1 - m2)/se )
end

function calc_root_stat2(m1, m1b, sd1, m2, m2b, sd2, M)
    # M^1    
    se = sqrt( ((sd1^2)/M) + ((sd2^2)/M) )
    abs( (m1b - m2b) - (m1 - m2)/se )
end


function calc_root_stat3(m1, m1b, sd1, m2, m2b, sd2, K)
    
    se = sqrt( (((sd1^2)) + ((sd2^2))) * (K^-1))
    abs( (m1b - m2b) - (m1 - m2)/se )
end


m1 = sample1["mean"]
m2 = sample2["mean"]

sd1 = sample1["sd"]
sd2 = sample2["sd"]

m1boots = sample1["bootstrap_means"]
m2boots = sample2["bootstrap_means"]



r_stats = []

for i in 1:K
    push!(r_stats, calc_root_stat1(m1, m1boots[i], sd1, m2, m2boots[i], sd2, N))
end

r_stats

histogram(r_stats)
```

## Under the alternative

Create two new samples, this time give one a different mean but a similar standard deviation.

```{julia}

new_samples = [
    rand(Normal(mu, sd), N),
    # introduce a mean that is higher
    rand(Normal(4, sd), N)
]

sample3 = get_batch_info(new_samples[1], "sample3", K)
sample4 = get_batch_info(new_samples[2], "sample4", K)
```

### Method 1

```{julia}

m1 = sample3["mean"]
m2 = sample4["mean"]

sd1 = sample3["sd"]
sd2 = sample4["sd"]

m1boots = sample3["bootstrap_means"]
m2boots = sample4["bootstrap_means"];
```

```{julia}

r_stats = []

for i in 1:K
    push!(r_stats, calc_root_stat1(m1, m1boots[i], sd1, m2, m2boots[i], sd2, N))
end

r_stats

histogram(r_stats)
```

```{julia}


d = quantile(r_stats, 1-0.05)

println("d is: ", d)

se = sqrt( ((sd1^2)/N) + ((sd2^2)/N) )

println("low ", (m1 - m2) - (d*se) )
println("observed ", (m1 - m2))
println("high ", (m1 - m2) + (d*se) )
```

### Method 2

```{julia}

r_stats = []

for i in 1:K
    push!(r_stats, calc_root_stat2(m1, m1boots[i], sd1,
                                    m2, m2boots[i], sd2, K))
end

r_stats

histogram(r_stats)
```

```{julia}

d = quantile(r_stats, 1-0.05)

println("d is: ", d)

se = sqrt( ((sd1^2)/K) + ((sd2^2)/K) )

println("low ", (m1 - m2) - (d*se) )
println("observed ", (m1 - m2))
println("high ", (m1 - m2) + (d*se) )
```


## Method 3

```{julia}

r_stats = []

for i in 1:K
    push!(r_stats, calc_root_stat3(m1, m1boots[i], sd1,
                                    m2, m2boots[i], sd2, K))
end

r_stats

histogram(r_stats)
```

```{julia}

d = quantile(r_stats, 1-0.05)

println("d is: ", d)

se = sqrt( ((sd1^2)) + ((sd2^2)) * (K * N) )

println("low ", (m1 - m2) - (d*se) )
println("observed ", (m1 - m2))
println("high ", (m1 - m2) + (d*se) )
```