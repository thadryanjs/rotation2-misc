
```{julia}

using Random
using Distributions
using Plots
# using LaTeXStrings
```

```{julia}

Random.seed!(8675309)

n_samples = 2
mu = 2
sd = 0.5
N = 1000
n_bins = 10 
bin_size = Int(N/n_bins)
normal_dist = Normal(mu, sd)
```


```{julia}

norm_samples = Vector{Number}[]

for i in 1:n_samples
    push!(norm_samples, rand(normal_dist, N))
end

# inspect
for i in norm_samples
    println(i[1:5], "\n")
end
```


We inspect the dataset to make sure we're getting what we think we are:

```{julia}
histogram(norm_samples[1])
```

We now want to apply the transformation to make them log-normal.

$$
X \sim Normal(\mu, \sigma)
$$

...then,

$$
exp(X) \sim LogNormal(\mu,\sigma)
$$


```{julia}

exp_vector(vec) = [exp(i) for i in vec]

samples = [exp_vector(sample) for sample in norm_samples]

histogram(samples[1])
```


We can see we've transformed it. The first step in the algorithm calls for calculating $\theta$ s for each of our samples:





```{julia}


function get_sample_info(sample, sample_name; n_bins)    

    theta_boots = []

    j = 1
    for x in 1:n_bins
        k = j  + (bin_size-1)
        # println("from ", j, " to ", k)
        push!(theta_boots, mean(sample[j:k]))
        j += bin_size
    end

    output = Dict()
    
    output["name"] = sample_name
    output["mean"] = mean(sample)
    output["sd"] = std(sample)
    output["bootstrap_means"] = theta_boots
    
    output

end

sample1 = get_sample_info(samples[1], "sample1", n_bins = n_bins)
```

Now we have a dictionary containing the information about a samples we need to compare it to another.

```{julia}
sample1
```


We will get another sample to compare it to.

```{julia}
sample2 = get_sample_info(samples[2], "sample2", n_bins = n_bins)
```



```{julia}

function calcR(t, tb, sd, t_hat, tb_hat, sd_hat, j, jp)

    # println("Compare ", j, " to ", jp)

    se = sqrt( ((sd^2)/1000) + ((sd_hat^2)/1000) )
    abs((tb - tb_hat) - (t - tb)/se)   
    
end
```

## Under the null

```{julia}

function calc_root_stat(m1, m1b, sd1, m2, m2b, sd2)
    
    se = sqrt( ((sd1)/1000) + ((sd2^2)/1000) )
    abs( (m1b - m2b) - (m1 - m2)/se )
end



m1 = sample1["mean"]
m2 = sample2["mean"]

sd1 = sample1["sd"]
sd2 = sample2["sd"]

m1boots = sample1["bootstrap_means"]
m2boots = sample2["bootstrap_means"]



r_stats = []

for i in 1:n_bins
    push!(r_stats, calc_root_stat(m1, m1boots[i], sd1, m2, m2boots[i], sd2))
end

r_stats

histogram(r_stats)
```



```{julia}
new_samples = [
    rand(Normal(mu, sd), 1000),
    rand(Normal(4, sd), 1000)
]

sample3 = get_sample_info(new_samples[1], "sample3", n_bins = 10)
sample4 = get_sample_info(new_samples[2], "sample4", n_bins = 10)
```

## Under the alternative

```{julia}

m1 = sample3["mean"]
m2 = sample4["mean"]

sd1 = sample3["sd"]
sd2 = sample4["sd"]

m1boots = sample3["bootstrap_means"]
m2boots = sample4["bootstrap_means"]

r_stats = []

for i in 1:n_bins
    push!(r_stats, calc_root_stat(m1, m1boots[i], sd1, m2, m2boots[i], sd2))
end

r_stats

histogram(r_stats)
```
























```{julia}

# for m1b in m1boots
#     for m2b in m2boots
#         println(m1b, " ", m2b)
#     end
# end
```


```{julia}
# a list of the sample names in order
# sample_names = [string("sample", i) for i in 1:length(samples)]
 
# # for every sample...
# for j in sample_names
    
#     t = thetas[j][1]
#     sd = thetas[j][2]
#     tb = theta_boots[j][1]
    
#     # ...for every *other* sample (not itself)
#     for jp in sample_names
#         if j != jp
#             t_hat = thetas[jp][1]
#             sd_hat = thetas[jp][2]
#             tb_hat = theta_boots[jp][1]
#             calcR(t, tb, sd, t_hat, tb_hat, sd_hat, j, jp)
#         end
#     end

# end

```





```{julia}

# generate_dataset(normal_dist, n = 3)

# samples = [exp_vector(sample) for sample in generate_dataset(normal_dist, n = 3)]

# thetas = get_thetas(samples)

# theta_boots = get_theta_boots(thetas)

# # a list of the sample names in order
# sample_names = [string("sample", i) for i in 1:length(samples)]
 
# # for every sample...
# for j in sample_names
    
#     t = thetas[j][1]
#     sd = thetas[j][2]
#     tb = theta_boots[j][1]
    
#     # ...for every *other* sample (not itself)
#     for jp in sample_names
#         if j != jp
#             t_hat = thetas[jp][1]
#             sd_hat = thetas[jp][2]
#             tb_hat = theta_boots[jp][1]
#             calcR(t, tb, sd, t_hat, tb_hat, sd_hat, j, jp)
#         end
#     end

# end

# function algorithmI(reps)

#     generate_dataset(normal_dist, n = 3)

#     samples = [exp_vector(sample) for sample in generate_dataset(normal_dist, n = 3)]

#     thetas = get_thetas(samples)

#     for rep_num in 1:reps

#         println("rep: ", rep_num)

#         theta_boots = get_theta_boots(thetas)

#         # a list of the sample names in order
#         sample_names = [string("sample", i) for i in 1:length(samples)]
        
#         # for every sample...
#         for j in sample_names
            
#             t = thetas[j][1]
#             sd = thetas[j][2]
#             tb = theta_boots[j][1]
            
#             # ...for every *other* sample (not itself)
#             for jp in sample_names
#                 if j != jp
#                     t_hat = thetas[jp][1]
#                     sd_hat = thetas[jp][2]
#                     tb_hat = theta_boots[jp][1]
#                     calcR(t, tb, sd, t_hat, tb_hat, sd_hat, j, jp)
#                 end
#             end

#         end    
#     end

# end

# algorithmI(4)
```
